library(tidyverse)
library(bs4Dash)
bs4DashGallery()
install.packages(thematic)
install.packages("thematic")
library(bs4Dash)
bs4DashGallery()
library(bs4Dash)
bs4DashGallery()
install.packages("extrafont")
tinytex::tlmgr_update()
--all
tlmgr update --all --self
tinytex
tinytex::tlmgr_install("sourcesanspro")
fc-list | grep "Source Sans"
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(readr)
library(stringr)
data <- read_csv("ica_cleaned_data.csv", show_col_types = FALSE)
year <- 2025
total_responses <- nrow(data)
# Define the capacity categories, matching the exact column names in the dataset
capacity_categories <- c(
"Clarity of Vision",
"Mission and Purpose",
"Policy and Legal framework",
"Responsiveness to changes in the operating environment\n",
"Strategic plan (Corporate or business plan)",
"Strategic planning process",
"Plan review processes",
"Budget and financial management",
"Program and service relevance and integration",
"Structure and function",
"Individual job design",
"Operational procedures (e.g. staff manual/ workplace procedures)",
"Internal coordination",
"Access to suitable Administrative/ Office support staff",
"Access to suitable technical/ professional staff",
"Staff Performance and feedback",
"Human resource development and training",
"Staff retention",
"Decision making",
"Staff engagement and communication",
"Workplace meetings (e.g. management, staff, team)",
"Change management and project implementation",
"Service delivery standards",
"Stakeholder partnerships (e.g. NGO, CSOs, FBOs)",
"Organisational Performance monitoring (M&E)",
"Teamwork and the interpersonal environment",
"Service as a shared value",
"Workplace learning",
"Managing workplace and out-of-work responsibilities",
"Physical infrastructure",
"Technological infrastructure"
)
# Calculate mean scores by ministry for each capacity category
ministry_stats <- data %>%
group_by(Ministry) %>%
summarise(across(all_of(capacity_categories), mean, na.rm = TRUE)) %>%
pivot_longer(cols = all_of(capacity_categories), names_to = "Category", values_to = "Mean_Score") %>%
mutate(Mean_Score = round(Mean_Score, 2),
Category = str_trim(gsub("\n", "", Category)))
# Calculate overall capacity score per ministry (average across all categories)
overall_capacity <- ministry_stats %>%
group_by(Ministry) %>%
summarise(Overall_Score = round(mean(Mean_Score, na.rm = TRUE), 2)) %>%
arrange(desc(Overall_Score))
# Identify strongest and weakest ministries
strongest_ministries <- overall_capacity %>%
slice_head(n = 2) %>%
select(Ministry, Overall_Score)
weakest_ministries <- overall_capacity %>%
filter(Overall_Score <= 2) %>%
arrange(Overall_Score) %>%
select(Ministry, Overall_Score)
# Identify strongest and weakest capacity categories per ministry
strongest_by_category <- ministry_stats %>%
group_by(Category) %>%
slice_max(order_by = Mean_Score, n = 1, with_ties = FALSE) %>%
select(Category, Ministry, Mean_Score)
weakest_by_category <- ministry_stats %>%
group_by(Category) %>%
slice_min(order_by = Mean_Score, n = 1, with_ties = FALSE) %>%
filter(Mean_Score <= 2) %>%
select(Category, Ministry, Mean_Score)
# Generate heatmap data
heatmap_data <- ministry_stats %>%
pivot_wider(names_from = Category, values_from = Mean_Score)
# Calculate descriptive stats by ministry
desc_stats_by_ministry <- data %>%
group_by(Ministry) %>%
summarise(across(all_of(capacity_categories), list(
mean = ~mean(., na.rm = TRUE),
sd = ~sd(., na.rm = TRUE),
min = ~min(., na.rm = TRUE),
max = ~max(., na.rm = TRUE),
median = ~median(., na.rm = TRUE)
))) %>%
pivot_longer(cols = -Ministry, names_to = c("Category", ".value"), names_sep = "_") %>%
mutate(across(c(mean, sd), ~round(., 2)),
Category = str_trim(gsub("\n", "", Category)))
# Response counts by ministry
response_counts <- data %>%
group_by(Ministry) %>%
summarise(Responses = n())
# Prepare data: Identify top 5 strongest and weakest categories
category_ranks <- ministry_stats %>%
group_by(Category) %>%
summarise(Avg_Score = mean(Mean_Score, na.rm = TRUE)) %>%
arrange(Avg_Score)
weakest_categories <- head(category_ranks$Category, 5)
strongest_categories <- tail(category_ranks$Category, 5)
focus_categories <- c(weakest_categories, strongest_categories)
# Filter data for focus categories and assign capacity levels
plot_data <- ministry_stats %>%
filter(Category %in% focus_categories) %>%
mutate(
Capacity_Level = case_when(
Mean_Score <= 1.5 ~ "Clear Need",
Mean_Score <= 2.5 ~ "Basic",
Mean_Score <= 3.5 ~ "Moderate",
Mean_Score > 3.5 ~ "High",
TRUE ~ NA_character_
),
Category = factor(Category, levels = category_ranks$Category)
) %>%
group_by(Ministry, Capacity_Level) %>%  # Group by Ministry and Capacity_Level only
summarise(Total_Score = sum(Mean_Score, na.rm = TRUE), .groups = "drop") %>%
mutate(Capacity_Level = factor(Capacity_Level, levels = c("Clear Need", "Basic", "Moderate", "High")))
# Create stacked bar chart
ggplot(plot_data, aes(x = Ministry, y = Total_Score, fill = Capacity_Level)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Clear Need" = "#8B0000", "Basic" = "#FF0000", "Moderate" = "#FFA500", "High" = "#00FF00")) +
geom_hline(yintercept = c(5, 10, 15, 20), linetype = "dashed", color = c("#8B0000", "#FF0000", "#FFA500", "#00FF00")) +
annotate("text", x = Inf, y = 5, label = "Clear Need (≤1.5)", hjust = 1.1, vjust = -0.5, color = "#8B0000", size = 3) +
annotate("text", x = Inf, y = 10, label = "Basic (≤2.5)", hjust = 1.1, vjust = -0.5, color = "#FF0000", size = 3) +
annotate("text", x = Inf, y = 15, label = "Moderate (≤3.5)", hjust = 1.1, vjust = -0.5, color = "#FFA500", size = 3) +
annotate("text", x = Inf, y = 20, label = "High (>3.5)", hjust = 1.1, vjust = -0.5, color = "#00FF00", size = 3) +
coord_cartesian(ylim = c(0, 20)) +  # Adjust based on max possible score (10 categories * avg ~2)
labs(x = "Ministry", y = "Total Mean Score Across Categories", fill = "Capacity Level") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
axis.text.y = element_text(size = 8),
axis.title = element_text(size = 9, face = "bold"),
legend.position = "top",
legend.text = element_text(size = 7),
legend.title = element_text(size = 8, face = "bold"),
panel.grid.major.x = element_blank(),
panel.grid.minor = element_blank())
# Prepare data: Identify top 5 strongest and weakest categories
category_ranks <- ministry_stats %>%
group_by(Category) %>%
summarise(Avg_Score = mean(Mean_Score, na.rm = TRUE)) %>%
arrange(Avg_Score)
weakest_categories <- head(category_ranks$Category, 5)
strongest_categories <- tail(category_ranks$Category, 5)
focus_categories <- c(weakest_categories, strongest_categories)
# Filter data for focus categories and assign capacity levels
plot_data <- ministry_stats %>%
filter(Category %in% focus_categories) %>%
mutate(
Capacity_Level = case_when(
Mean_Score <= 1.5 ~ "Clear Need",
Mean_Score <= 2.5 ~ "Basic",
Mean_Score <= 3.5 ~ "Moderate",
Mean_Score > 3.5 ~ "High",
TRUE ~ NA_character_
),
Category = factor(Category, levels = category_ranks$Category)
) %>%
group_by(Ministry, Capacity_Level) %>%  # Group by Ministry and Capacity_Level only
summarise(Total_Score = sum(Mean_Score, na.rm = TRUE), .groups = "drop") %>%
mutate(Capacity_Level = factor(Capacity_Level, levels = c("Clear Need", "Basic", "Moderate", "High")))
# Create stacked bar chart
ggplot(plot_data, aes(x = Ministry, y = Total_Score, fill = Capacity_Level)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Clear Need" = "#8B0000", "Basic" = "#FF0000", "Moderate" = "#FFA500", "High" = "#00FF00")) +
geom_hline(yintercept = c(5, 10, 15, 20), linetype = "dashed", color = c("#8B0000", "#FF0000", "#FFA500", "#00FF00")) +
annotate("text", x = Inf, y = 5, label = "Clear Need (≤1.5)", hjust = 1.1, vjust = -0.5, color = "#8B0000", size = 3) +
annotate("text", x = Inf, y = 10, label = "Basic (≤2.5)", hjust = 1.1, vjust = -0.5, color = "#FF0000", size = 3) +
annotate("text", x = Inf, y = 15, label = "Moderate (≤3.5)", hjust = 1.1, vjust = -0.5, color = "#FFA500", size = 3) +
annotate("text", x = Inf, y = 20, label = "High (>3.5)", hjust = 1.1, vjust = -0.5, color = "#00FF00", size = 3) +
coord_cartesian(ylim = c(0, 20)) +  # Adjust based on max possible score (10 categories * avg ~2)
labs(x = "Ministry", y = "Total Mean Score Across Categories", fill = "Capacity Level") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
axis.text.y = element_text(size = 8),
axis.title = element_text(size = 9, face = "bold"),
legend.position = "top",
legend.text = element_text(size = 7),
legend.title = element_text(size = 8, face = "bold"),
panel.grid.major.x = element_blank(),
panel.grid.minor = element_blank())
library(dplyr)
library(readr)
library(stringr)
library(quarto)
# Store the original working directory
original_wd <- getwd()
setwd("~/Documents/Work/ICA/ICA Report")
# Load data
data <- read_csv("ica_cleaned_data.csv", show_col_types = FALSE) %>%
group_by(Ministry, Department) %>%
filter(n() > 4) %>%
ungroup()
# Get unique Ministry names and convert to safe names
unique_ministries <- data %>%
select(Ministry) %>%
distinct() %>%
arrange(Ministry) %>%
mutate(safe_min = str_replace_all(Ministry, "[^[:alnum:]]", "_"))
# Print the safe Ministry names for reference
cat("Safe Ministry Names (used for folder creation):\n")
print(unique_ministries$safe_min)
# Create a folder for each unique Ministry
for (ministry in unique_ministries$safe_min) {
dir.create(file.path("Reports", ministry), showWarnings = FALSE, recursive = TRUE)
}
# Get unique Ministry and Department pairs
unique_ministry_dept <- data %>%
select(Ministry, Department) %>%
distinct() %>%
arrange(Ministry)
# Loop through each pair and render a report
for (i in seq_len(nrow(unique_ministry_dept))) {
params_list <- list(
ministry = unique_ministry_dept$Ministry[i],
department = unique_ministry_dept$Department[i]
)
# Create safe names for Ministry and Department
safe_dept <- str_replace_all(unique_ministry_dept$Department[i], "[^[:alnum:]]", "_")
safe_min <- str_replace_all(unique_ministry_dept$Ministry[i], "[^[:alnum:]]", "_")
# Define output file name (just the file name)
output_file <- paste0("ICA_Report_", safe_dept, ".pdf")
# Define the target path in the Ministry folder
ministry_folder <- file.path("Reports", safe_min)
target_path <- file.path(ministry_folder, output_file)
# Render the report to the original working directory
quarto::quarto_render(
input = file.path(original_wd, "ICA_Report_Template.qmd"),
execute_params = params_list,
output_file = output_file,
output_format = "pdf"
)
# Move the rendered PDF to the Ministry folder
if (file.exists(file.path(original_wd, output_file))) {
file.rename(file.path(original_wd, output_file), target_path)
} else {
warning(paste("PDF not found:", output_file, "for", params_list$department))
}
}
library(dplyr)
library(readr)
library(stringr)
library(quarto)
# Store the original working directory
original_wd <- getwd()
setwd("~/Documents/Work/ICA/ICA Report")
# Load data
data <- read_csv("ica_cleaned_data.csv", show_col_types = FALSE) %>%
group_by(Ministry, Department) %>%
filter(n() > 4) %>%
ungroup()
# Get unique Ministry names and convert to safe names
unique_ministries <- data %>%
select(Ministry) %>%
distinct() %>%
arrange(Ministry) %>%
mutate(safe_min = str_replace_all(Ministry, "[^[:alnum:]]", "_"))
# Print the safe Ministry names for reference
cat("Safe Ministry Names (used for folder creation):\n")
print(unique_ministries$safe_min)
# Create a folder for each unique Ministry
for (ministry in unique_ministries$safe_min) {
dir.create(file.path("Reports", ministry), showWarnings = FALSE, recursive = TRUE)
}
# Get unique Ministry and Department pairs
unique_ministry_dept <- data %>%
select(Ministry, Department) %>%
distinct() %>%
arrange(Ministry)
# Loop through each pair and render a report
for (i in seq_len(nrow(unique_ministry_dept))) {
params_list <- list(
ministry = unique_ministry_dept$Ministry[i],
department = unique_ministry_dept$Department[i]
)
# Create safe names for Ministry and Department
safe_dept <- str_replace_all(unique_ministry_dept$Department[i], "[^[:alnum:]]", "_")
safe_min <- str_replace_all(unique_ministry_dept$Ministry[i], "[^[:alnum:]]", "_")
# Define output file name (just the file name)
output_file <- paste0("ICA_Report_", safe_dept, ".pdf")
# Define the target path in the Ministry folder
ministry_folder <- file.path("Reports", safe_min)
target_path <- file.path(ministry_folder, output_file)
# Render the report to the original working directory
quarto::quarto_render(
input = file.path(original_wd, "ICA_Report_Template.qmd"),
execute_params = params_list,
output_file = output_file,
output_format = "pdf"
)
# Move the rendered PDF to the Ministry folder
if (file.exists(file.path(original_wd, output_file))) {
file.rename(file.path(original_wd, output_file), target_path)
} else {
warning(paste("PDF not found:", output_file, "for", params_list$department))
}
}
library(dplyr)
library(readr)
library(stringr)
library(quarto)
# Store the original working directory
original_wd <- getwd()
setwd("~/Documents/Work/ICA/ICA Report")
# Load data
data <- read_csv("ica_cleaned_data.csv", show_col_types = FALSE) %>%
group_by(Ministry, Department) %>%
filter(n() > 4) %>%
ungroup()
# Get unique Ministry names and convert to safe names
unique_ministries <- data %>%
select(Ministry) %>%
distinct() %>%
arrange(Ministry) %>%
mutate(safe_min = str_replace_all(Ministry, "[^[:alnum:]]", "_"))
# Print the safe Ministry names for reference
cat("Safe Ministry Names (used for folder creation):\n")
print(unique_ministries$safe_min)
# Create a folder for each unique Ministry
for (ministry in unique_ministries$safe_min) {
dir.create(file.path("Reports", ministry), showWarnings = FALSE, recursive = TRUE)
}
# Get unique Ministry and Department pairs
unique_ministry_dept <- data %>%
select(Ministry, Department) %>%
distinct() %>%
arrange(Ministry)
# Loop through each pair and render a report
for (i in seq_len(nrow(unique_ministry_dept))) {
params_list <- list(
ministry = unique_ministry_dept$Ministry[i],
department = unique_ministry_dept$Department[i]
)
# Create safe names for Ministry and Department
safe_dept <- str_replace_all(unique_ministry_dept$Department[i], "[^[:alnum:]]", "_")
safe_min <- str_replace_all(unique_ministry_dept$Ministry[i], "[^[:alnum:]]", "_")
# Define output file name (just the file name)
output_file <- paste0("ICA_Report_", safe_dept, ".pdf")
# Define the target path in the Ministry folder
ministry_folder <- file.path("Reports", safe_min)
target_path <- file.path(ministry_folder, output_file)
# Render the report to the original working directory
quarto::quarto_render(
input = file.path(original_wd, "ICA_Report_Template.qmd"),
execute_params = params_list,
output_file = output_file,
output_format = "pdf"
)
# Move the rendered PDF to the Ministry folder
if (file.exists(file.path(original_wd, output_file))) {
file.rename(file.path(original_wd, output_file), target_path)
} else {
warning(paste("PDF not found:", output_file, "for", params_list$department))
}
}
# Ensure the working directory is restored (though not strictly necessary here)
setwd(original_wd)
