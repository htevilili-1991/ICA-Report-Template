install.packages("tinytex")
tinytex::install_tinytex()
tinytex::tlmgr_install("sourcesanspro")
pop2020<- dbGetQuery(mydb, "SELECT province, area_council, religion, village, sex, ac_factor
FROM person
WHERE can_enumerate = 1 AND age>=7 AND age<=25 AND area_council='port vila' AND village IN('freswota 1','freswota 2','freswota 3','freswota 4','freswota 5','freswota 6','2nd lagoon','korman stadium','tasiriki (vila)','stade')
ORDER BY province_id, area_council_id, religion, village") %>%
select(province, area_council, religion, village, sex, ac_factor) %>%
pivot_wider(names_from=c(religion,sex),
values_from=ac_factor,
values_fn = sum,
values_fill = 0)
#### Load Libraries and data ####
#Removes all objects from the current workspace
rm(list = ls())
library(RSQLite) #allows to CRUD in SQLite database
library(dplyr) # for data manipulation and transformation tasks
library(tidyverse) #aimed at making data manipulation and visualization tasks more intuitive and efficient
library(tidyr) #used for cleaning and reshaping data sets by converting between "wide" and "long" formats, filling or imputing missing values, and separating or combining columns
library(openxlsx) #only used here for exporting to .xlsx
# The file.path() function takes a series of path components as arguments and returns a single path string with appropriate separators between the components for the current operating system.
#In this case, file.path() is used to get the directory path of the current source editor context in RStudio using the rstudioapi::getSourceEditorContext() function. The $path attribute of this function returns the full path to the currently active file in the editor. The dirname() function is then used to extract the directory path from the full path
repository <- file.path(dirname(rstudioapi::getSourceEditorContext()$path))
setwd(repository) # sets the working directory to the 'repository' variable
# Establish connection to the SQLite database. The connection is established using the RSQLite package's dbConnect() function and the SQLite driver.
#The connection object mydb is created to store the connection details, which can then be used to read data from or write data to the database
mydb <- dbConnect(RSQLite::SQLite(), "data/secure/sqlite/census2020 - withNewAreaCouncils.SQLite")
#mydb <- dbConnect(RSQLite::SQLite(), "data/secure/sqlite/census2020 - withOldAreaCouncils.SQLite")
pop2020<- dbGetQuery(mydb, "SELECT province, area_council, religion, village, sex, ac_factor
FROM person
WHERE can_enumerate = 1 AND age>=7 AND age<=25 AND area_council='port vila' AND village IN('freswota 1','freswota 2','freswota 3','freswota 4','freswota 5','freswota 6','2nd lagoon','korman stadium','tasiriki (vila)','stade')
ORDER BY province_id, area_council_id, religion, village") %>%
select(province, area_council, religion, village, sex, ac_factor) %>%
pivot_wider(names_from=c(religion,sex),
values_from=ac_factor,
values_fn = sum,
values_fill = 0)
View(pop2020)
tinytex::tlmgr_install("dejavu")
fc-list | grep "DejaVu Sans"
pop2020<- dbGetQuery(mydb, "SELECT province, area_council, religion, village, sex, ac_factor
FROM person
WHERE can_enumerate = 1 AND age>=7 AND age<=25 AND area_council='port vila' AND village IN('freswota 1','freswota 2','freswota 3','freswota 4','freswota 5','freswota 6','2nd lagoon','korman stadium','tasiriki (vila)','stade')
ORDER BY province_id, area_council_id, religion, village") %>%
select(province, area_council, religion, village, sex, ac_factor) %>%
pivot_wider(names_from=c(religion,sex),
values_from=ac_factor,
values_fn = sum,
values_fill = 0)
#### Load Libraries and data ####
#Removes all objects from the current workspace
rm(list = ls())
library(RSQLite) #allows to CRUD in SQLite database
library(dplyr) # for data manipulation and transformation tasks
library(tidyverse) #aimed at making data manipulation and visualization tasks more intuitive and efficient
library(tidyr) #used for cleaning and reshaping data sets by converting between "wide" and "long" formats, filling or imputing missing values, and separating or combining columns
library(openxlsx) #only used here for exporting to .xlsx
# The file.path() function takes a series of path components as arguments and returns a single path string with appropriate separators between the components for the current operating system.
#In this case, file.path() is used to get the directory path of the current source editor context in RStudio using the rstudioapi::getSourceEditorContext() function. The $path attribute of this function returns the full path to the currently active file in the editor. The dirname() function is then used to extract the directory path from the full path
repository <- file.path(dirname(rstudioapi::getSourceEditorContext()$path))
setwd(repository) # sets the working directory to the 'repository' variable
# Establish connection to the SQLite database. The connection is established using the RSQLite package's dbConnect() function and the SQLite driver.
#The connection object mydb is created to store the connection details, which can then be used to read data from or write data to the database
mydb <- dbConnect(RSQLite::SQLite(), "data/secure/sqlite/census2020 - withNewAreaCouncils.SQLite")
#mydb <- dbConnect(RSQLite::SQLite(), "data/secure/sqlite/census2020 - withOldAreaCouncils.SQLite")
pop2020<- dbGetQuery(mydb, "SELECT province, area_council, religion, village, sex, ac_factor
FROM person
WHERE can_enumerate = 1 AND age>=7 AND age<=25 AND area_council='port vila' AND village IN('stade')
ORDER BY province_id, area_council_id, religion, village") %>%
select(province, area_council, religion, village, sex, ac_factor) %>%
pivot_wider(names_from=c(religion,sex),
values_from=ac_factor,
values_fn = sum,
values_fill = 0)
write.xlsx(pop2020, "stade.xlsx", rowNames = FALSE)
setwd("~/Documents/Work/ICA")
setwd("~/Documents/Work/ICA")
quarto add quarto-ext/titlepage
setwd("~/Documents/Work/ICA")
tinytex::uninstall_tinytex()
tinytex::install_tinytex()
tlmgr install hyphenat
install.packages("systemfonts")
library(systemfonts)
system_fonts()
clear
cls
clear
#| label: setup
#| message: false
#| warning: false
#| echo: false
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(readr)
library(stringr)
# Hardcode department and ministry
department <- "Department of Forestry"
ministry <- "Ministry of Agriculture, Livestock, Forestry, Fisheries and Biosecurity"
#| echo: false
#| include: FALSE
# Read the dataset
data <- read_csv("ica_cleaned_data.csv", show_col_types = FALSE)
# Define the capacity categories, matching the exact column names in the dataset
capacity_categories <- c(
"Clarity of Vision",
"Mission and Purpose",
"Policy and Legal framework",
"Responsiveness to changes in the operating environment\n",
"Strategic plan (Corporate or business plan)",
"Strategic planning process",
"Plan review processes",
"Budget and financial management",
"Program and service relevance and integration",
"Structure and function",
"Individual job design",
"Operational procedures (e.g. staff manual/ workplace procedures)",
"Internal coordination",
"Access to suitable Administrative/ Office support staff",
"Access to suitable technical/ professional staff",
"Staff Performance and feedback",
"Human resource development and training",
"Staff retention",
"Decision making",
"Staff engagement and communication",
"Workplace meetings (e.g. management, staff, team)",
"Change management and project implementation",
"Service delivery standards",
"Stakeholder partnerships (e.g. NGO, CSOs, FBOs)",
"Organisational Performance monitoring (M&E)",
"Teamwork and the interpersonal environment",
"Service as a shared value",
"Workplace learning",
"Managing workplace and out-of-work responsibilities",
"Physical infrastructure",
"Technological infrastructure"
)
# Filter data for the Department of Forestry
forestry_data <- data %>%
filter(Department == department)
# Calculate mean scores for each capacity category
category_stats <- forestry_data %>%
select(all_of(capacity_categories)) %>%
summarise_all(mean, na.rm = TRUE) %>%
pivot_longer(cols = everything(), names_to = "Category", values_to = "Mean_Score") %>%
mutate(Mean_Score = round(Mean_Score, 2)) %>%
# Clean up category names for output (remove trailing newlines)
mutate(Category = str_trim(gsub("\n", "", Category)))
# Generate strongest capacities (top 2 based on mean score)
strongest <- category_stats %>%
arrange(desc(Mean_Score)) %>%
slice_head(n = 2) %>%
select(Category, Mean_Score)
# Generate weakest capacities (bottom categories with Mean_Score <= 2)
weakest <- category_stats %>%
filter(Mean_Score <= 2) %>%
arrange(Mean_Score) %>%
select(Category, Mean_Score)
# Generate rating counts for each category
rating_counts <- forestry_data %>%
select(all_of(capacity_categories)) %>%
pivot_longer(cols = everything(), names_to = "Category", values_to = "Score") %>%
mutate(Category = str_trim(gsub("\n", "", Category))) %>%
group_by(Category, Score) %>%
summarise(Count = n(), .groups = "drop") %>%
pivot_wider(names_from = Score, values_from = Count, values_fill = 0)
# Generate fig3_data (same as category_stats for the bar plot)
fig3_data <- category_stats
View(data)
